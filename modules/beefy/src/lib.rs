// Copyright 2021 Parity Technologies (UK) Ltd.
// This file is part of Parity Bridges Common.

// Parity Bridges Common is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Bridges Common is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Bridges Common.  If not, see <http://www.gnu.org/licenses/>.

//! BEEFY bridge pallet.
//!
//! This pallet is an on-chain BEEFY client for Substrate-based chains that are using following
//! pallets bundle: `pallet-mmr`, `pallet-beefy` and `pallet-beefy-mmr`.
//!
//! The pallet is able to verify MMR leaf proofs, so it has a **direct** access to the following
//! data of the bridged chain:
//!
//! - header hashes;
//! - changes of BEEFY authorities;
//! - extra data of MMR leafs (e.g. parachains heads when bridged with relay chain and properly configured).
//!
//! Given the header hash (and parachain heads), other pallets are able to verify header-based
//! proofs. For example - storage proofs, transaction inclustion proofs, ...There are two options to
//! do that:
//!
//! - the cheap option only works when proof is header-proof is based on some recent header. Then
//!   the submitter may relay on the fact that the pallet is storing hashes of the most recent bridged
//!   headers. Then you may ensure that the provided header is valid by checking that the `RecentHeaderHashes`
//!   map contains an entry for your header.
//! - the expensive option works for any header that is "covered" with MMR. The proof then must
//!   include MMR proof for leaf, corresponding to the header and the header itself.

#![cfg_attr(not(feature = "std"), no_std)]

use bp_beefy::{BeefyMmrProof, ChainWithBeefy};

// Re-export in crate namespace for `construct_runtime!`
pub use pallet::*;

/// Configured bridged chain.
pub type BridgedChain<T, I> = <T as Config<I>>::BridgedChain;
/// Block number, used by configured bridged chain.
pub type BridgedBlockNumber<T, I> = bp_runtime::BlockNumberOf<BridgedChain<T, I>>;
/// Block hash, used by configured bridged chain.
pub type BridgedBlockHash<T, I> = bp_runtime::HashOf<BridgedChain<T, I>>;

/// BEEFY commitment hasher, used by configured bridged chain.
pub type BridgedBeefyCommitmentHasher<T, I> = bp_beefy::BeefyCommitmentHasher<BridgedChain<T, I>>;
/// BEEFY validator set, used by configured bridged chain.
pub type BridgedBeefyValidatorSet<T, I> = bp_beefy::BeefyValidatorSetOf<BridgedChain<T, I>>;
/// BEEFY signed commitment, used by configured bridged chain.
pub type BridgedBeefySignedCommitment<T, I> = bp_beefy::BeefySignedCommitmentOf<BridgedChain<T, I>>;
/// MMR hash algorithm, used by configured bridged chain.
pub type BridgedBeefyMmrHasher<T, I> = bp_beefy::BeefyMmrHasherOf<BridgedChain<T, I>>;
/// MMR leaf type, used by configured bridged chain.
pub type BridgedBeefyMmrLeaf<T, I> = bp_beefy::BeefyMmrLeafOf<BridgedChain<T, I>>;
/// TODO
pub type BridgedRawBeefyMmrLeaf<T, I> = bp_beefy::RawBeefyMmrLeafOf<BridgedChain<T, I>>;
/// A way to encode validator id to the BEEFY merkle tree leaf.
pub type BridgedBeefyValidatorIdToMerkleLeaf<T, I> =
	bp_beefy::BeefyValidatorIdToMerkleLeafOf<BridgedChain<T, I>>;

mod commitment;
mod leaf;

#[cfg(test)]
mod mock;
#[cfg(test)]
mod mock_chain;

#[frame_support::pallet]
pub mod pallet {
	use super::*;
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;

	#[pallet::config]
	pub trait Config<I: 'static = ()>: frame_system::Config {
		/// The chain we are bridging to here.
		type BridgedChain: ChainWithBeefy;
	}

	#[pallet::pallet]
	#[pallet::without_storage_info]
	pub struct Pallet<T, I = ()>(PhantomData<(T, I)>);

	#[pallet::call]
	impl<T: Config<I>, I: 'static> Pallet<T, I>
	where
		BridgedBeefyMmrHasher<T, I>: 'static + Send + Sync,
	{
		/// Submit commitment, generated by BEEFY validators.
		///
		/// Apart from the generic payload, the commitment contains the finalized (by BEEFY) block
		/// number, so they must be always be imported in order. Importing commitment gives us
		/// knowledge of header hash that has been finalized by BEEFY validators.
		#[pallet::weight(0)] // TODO: compute weights
		pub fn submit_commitment(
			origin: OriginFor<T>,
			// TODO: implement `TypeInfo` for `BridgedBeefySignedCommitment<T, I>`, `BeefyMmrProof`
			// and `BridgedBeefyMmrLeaf::<T, I>`
			encoded_commitment: Vec<u8>,
			encoded_mmr_proof: Vec<u8>,
			encoded_mmr_leaf: Vec<u8>,
		) -> DispatchResult {
			let _ = ensure_signed(origin)?;

			// verify BEEFY commitment: once verification is completed, we know that BEEFY
			// validators have finalized block with given number and given MMR root
			let best_block_number =
				BestBlockNumber::<T, I>::get().ok_or(Error::<T, I>::NotInitialized)?;
			let validators =
				CurrentValidatorSet::<T, I>::get().ok_or(Error::<T, I>::NotInitialized)?;
			let commitment =
				BridgedBeefySignedCommitment::<T, I>::decode(&mut &encoded_commitment[..])
					.map_err(|e| {
						log::error!(
							target: "runtime::bridge-beefy",
							"Signed commitment decode has failed with error: {:?}",
							e,
						);

						Error::<T, I>::FailedToDecodeArgument
					})?;

			log::trace!(
				target: "runtime::bridge-beefy",
				"Importing commitment for block {:?}",
				commitment.commitment.block_number,
			);

			let commitment_artifacts = commitment::verify_beefy_signed_commitment::<T, I>(
				best_block_number,
				&validators,
				&commitment,
			)?;

			// MMR proof verification
			let mmr_proof = BeefyMmrProof::decode(&mut &encoded_mmr_proof[..]).map_err(|e| {
				log::error!(
					target: "runtime::bridge-beefy",
					"MMR proof decode has failed with error: {:?}",
					e,
				);

				Error::<T, I>::FailedToDecodeArgument
			})?;
			let mmr_leaf = BridgedBeefyMmrLeaf::<T, I>::decode(&mut &encoded_mmr_leaf[..])
				.map_err(|e| {
					log::error!(
						target: "runtime::bridge-beefy",
						"MMR leaf decode has failed with error: {:?}",
						e,
					);

					Error::<T, I>::FailedToDecodeArgument
				})?;
			let mmr_leaf_artifacts = leaf::verify_beefy_mmr_leaf::<T, I>(
				&validators,
				&mmr_leaf,
				mmr_proof,
				commitment_artifacts.mmr_root,
			)?;

			// update storage
			BestBlockNumber::<T, I>::put(commitment.commitment.block_number);
			if let Some(new_next_validator_set) = mmr_leaf_artifacts.next_validator_set {
				let next_validator_set =
					NextValidatorSet::<T, I>::get().ok_or(Error::<T, I>::NotInitialized)?;
				log::info!(
					target: "runtime::bridge-beefy",
					"Enacting new BEEFY validator set #{} with {} validators. Next validator set: #{} with {} validators.",
					next_validator_set.id(),
					next_validator_set.len(),
					new_next_validator_set.id(),
					new_next_validator_set.len(),
				);

				CurrentValidatorSet::<T, I>::put(next_validator_set);
				NextValidatorSet::<T, I>::put(new_next_validator_set);
			}
			// TODO: store parent header number => hash to eb able to verify header-based proofs
			// TODO: store MMR root + parachain heads root for verifying later proofs

			log::info!(
				target: "runtime::bridge-beefy",
				"Successfully imported commitment for block {:?}",
				commitment.commitment.block_number,
			);

			Ok(())
		}
	}

	// TODO: request count

	/// Best known block number of the bridged chain, finalized by BEEFY.
	#[pallet::storage]
	pub type BestBlockNumber<T: Config<I>, I: 'static = ()> =
		StorageValue<_, BridgedBlockNumber<T, I>>;

	/// Current BEEFY validators set at the bridged chain.
	#[pallet::storage]
	pub type CurrentValidatorSet<T: Config<I>, I: 'static = ()> =
		StorageValue<_, BridgedBeefyValidatorSet<T, I>>;

	/// Next BEEFY validators set at the bridged chain.
	#[pallet::storage]
	pub type NextValidatorSet<T: Config<I>, I: 'static = ()> =
		StorageValue<_, BridgedBeefyValidatorSet<T, I>>;

	// TODO: pallet owner + is halted

	#[pallet::error]
	pub enum Error<T, I = ()> {
		/// Failed to decode method arguments (will be removed once `TypeInfo` wiwill be
		/// implemented for all arguments).
		FailedToDecodeArgument,
		/// The pallet has not been initialized yet.
		NotInitialized,
		/// The pallet has already been initialized.
		AlreadyInitialized,
		/// The commitment being imported is older than the best commitment known to the pallet.
		OldCommitment,
		/// The commitment is signed by unknown validator set.
		InvalidValidatorsSetId,
		/// The number of signatures in the commitment is invalid.
		InvalidSignaturesLength,
		/// There are not enough correct signatures in commitment to finalize block.
		NotEnoughCorrectSignatures,
		/// MMR root is missing from the commitment.
		MmrRootMissingFromCommitment,
		/// MMR proof verification has failed.
		MmrProofVeriricationFailed,
		/// MMR leaf version is unknown to us.
		UnsupportedMmrLeafVersion,
		/// Next validator set id is invalid.
		InvalidNextValidatorsSetId,
		/// Next validators are provided when leaf is not signalling set change.
		RedundantNextValidatorsProvided,
		/// Next validators are not matching the merkle tree root.
		InvalidNextValidatorSetRoot,
		/// Next validator set is empty.
		EmptyNextValidatorSet,
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use codec::Encode;
	use frame_support::assert_ok;
	use mock::*;
	use mock_chain::*;

	fn import_header_chain(headers: Vec<HeaderAndCommitment>) {
		for header in headers {
			if let Some(commitment) = header.commitment {
				assert_ok!(Pallet::<TestRuntime, ()>::submit_commitment(
					Origin::signed(1),
					commitment.encode(),
					header.leaf_proof.expect("TODO").encode(),
					header.leaf.expect("TODO").encode(),
				));
			}
		}
	}

	#[test]
	fn submit_commitment_works_with_regular_commitment() {
		run_test(|| {
			let validator_set = BridgedBeefyValidatorSet::<TestRuntime, ()>::new(
				validator_keys(0, 32).into_iter().map(|k| {
					sp_core::ecdsa::Public::from_raw(
						validator_key_to_public(k).serialize_compressed(),
					)
					.into()
				}),
				0,
			)
			.expect("TODO");
			let next_validator_set = BridgedBeefyValidatorSet::<TestRuntime, ()>::new(
				validator_keys(0, 32).into_iter().map(|k| {
					sp_core::ecdsa::Public::from_raw(
						validator_key_to_public(k).serialize_compressed(),
					)
					.into()
				}),
				1,
			)
			.expect("TODO");
			BestBlockNumber::<TestRuntime, ()>::put(0);
			CurrentValidatorSet::<TestRuntime, ()>::put(validator_set);
			NextValidatorSet::<TestRuntime, ()>::put(next_validator_set);

			let _ = env_logger::try_init();

			let chain = ChainBuilder::new(32)
				.append_default_headers(16)
				.append_finalized_header()
				.append_default_headers(16)
				.append_handoff_header(64)
				.append_default_headers(8)
				.append_finalized_header()
				.append_default_headers(8)
				.append_handoff_header(64)
				.append_default_headers(4)
				.append_finalized_header()
				.append_default_headers(4);
			import_header_chain(chain.into())

			// let encoded_commitment = <TODO>;
			// let encoded_mmr_proof = <TODO>;
			// let encoded_mmr_leaf = <TODO>;
			// assert_ok!(Pallet::<TestRuntime>::submit_commitment(
			// 	Origin::signed(1),
			// 	encoded_commitment,
			// 	encoded_mmr_proof,
			// 	encoded_mmr_leaf,
			// ));
			//
			// 	assert_eq!(BestFinalized::<TestRuntime>::get(), init_data.header.hash());
			//
			// TODO: ensure that the pallet storage has been updated
		})
	}
}
